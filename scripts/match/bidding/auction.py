import sys
import os
import platform
os.environ['FOR_DISABLE_CONSOLE_CTRL_HANDLER'] = 'T'
# Just disables the warnings
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
os.environ["GRPC_VERBOSITY"] = "ERROR"
os.environ["GLOG_minloglevel"] = "2"
os.environ["TF_ENABLE_ONEDNN_OPTS"] = "0"

sys.path.append('../../../src')

import logging

# Intil fixed in Keras, this is needed to remove a wrong warning
import warnings
warnings.filterwarnings("ignore")

# Set logging level to suppress warnings
logging.getLogger().setLevel(logging.ERROR)

# Configure absl logging to suppress logs
import absl.logging
# Suppress Abseil logs
absl.logging.get_absl_handler().python_handler.stream = open(os.devnull, 'w')
absl.logging.set_verbosity(absl.logging.FATAL)
absl.logging.set_stderrthreshold(absl.logging.FATAL)

import tensorflow as tf

import argparse
import json

import conf
import time
import datetime

import numpy as np

from bots import BotBid
from bidding import bidding
from sample import Sample
import uuid
import shelve

def get_execution_path():
    # Get the directory where the program is started from either PyInstaller executable or the script
    return os.getcwd()

VULN = {
    'None': [False, False],
    'N-S': [True, False],
    'E-W': [False, True],
    'Both': [True, True]
}


def bid_hand(hands, dealer, vuln, models_ns_ew, samplers, dds, verbose):

    dealer_i = 'NESW'.index(dealer)
    
    bidder_bots = [BotBid(VULN[vuln], hand, models_ns_ew[i % 2], samplers[i % 2], i, dealer_i, dds, verbose) for i, hand in enumerate(hands)]

    auction = ['PAD_START'] * dealer_i
    
    turn_i = dealer_i

    bid_responses = []
    while not bidding.auction_over(auction):
        if verbose:
            print("_________________________________")
            print("Turn", "NESW"[turn_i], hands[turn_i])
        bid_resp = bidder_bots[turn_i].bid(auction)
        bid_responses.append(bid_resp)
        auction.append(bid_resp.bid)
        turn_i = (turn_i + 1) % 4  # next player's turn
    
    return auction, bid_responses


def cleanup_shelf(shelf_filename):
    # Delete the shelf file if it exists
    if os.path.exists(shelf_filename + '.dat'):
        os.remove(shelf_filename + '.dat')
        # Remove other associated files generated by shelve
        for ext in ('.bak', '.dat', '.dir'):
            filename = shelf_filename + ext
            if os.path.exists(filename):
                os.remove(filename)

if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument('--bidderNS', type=str)
    parser.add_argument('--bidderEW', type=str)
    parser.add_argument('--set', type=str)
    parser.add_argument('--db', type=str)
    parser.add_argument("--verbose", type=bool, default=False, help="Print extra information")

    args = parser.parse_args()
    verbose = args.verbose

    sys.stderr.write(f'NS = {args.bidderNS}\n')
    sys.stderr.write(f'EW = {args.bidderEW}\n')    
    sys.stderr.write(f'DB = {args.db}\n')

    configuration_ns = conf.load(args.bidderNS)
    configuration_ew = conf.load(args.bidderEW)

    np.set_printoptions(precision=2, suppress=True)

    sys.stderr.write(f"Loading tensorflow {tf.__version__}\n")
    try:
        if configuration_ns["models"]['tf_version'] == "2":
            from nn.models_tf2 import Models
        else: 
            # Default to version 1. of Tensorflow
            from nn.models import Models
    except KeyError:
            # Default to version 1. of Tensorflow
            from nn.models import Models


    models_ns = Models.from_conf(configuration_ns,"../../..")
    models_ew = Models.from_conf(configuration_ew,"../../..")

    from ddsolver import ddsolver
    dds = ddsolver.DDSolver()

# Get the path to the config file
    config_path = get_execution_path()
    
    base_path = os.getenv('BEN_HOME') or config_path

    db_name = args.db
    #cleanup_shelf(f"{base_path}/{db_name}")

    for index, line in enumerate(open(args.set)):        
        # To make the boards reproducable random is seeded at the beginning of each board
        np.random.seed(42)
        t_start = time.time()

        parts = line.strip().split()
        dealer = parts[0]
        vuln = parts[1]
        hands = parts[2:]

        sys.stderr.write(f'Bidding board {index + 1} {verbose}\n')
        auction, bid_responses = bid_hand(hands, dealer, vuln, [models_ns, models_ew], [Sample.from_conf(configuration_ns), Sample.from_conf(configuration_ew)], dds, verbose)

        record = {
            'board' : index + 1,
            'contract': bidding.get_contract(auction),
            'dealer': dealer,
            'vuln': vuln,
            'north': hands[0],
            'east': hands[1],
            'south': hands[2],
            'west': hands[3],
            'auction': auction
        }

        print(json.dumps(record))
        sys.stdout.flush()
        if db_name:
            hands = ' '.join(hands)
            contract = bidding.get_contract(auction)
            result = {
                'timestamp': time.time(),
                'dealer': "NESW".index(dealer),
                'vuln_ns': VULN[vuln][0],
                'vuln_ew': VULN[vuln][1],
                'hands': hands,
                'bids': [b.to_dict() for b in bid_responses],
                'contract': contract,
                'play': None,
                'trick_winners': [],
                'board_number' : index + 1,
                'player': "Match",
                'rotated': False,
                'play_only': False,
                'bidding_only': True,
                'human': False,
                'declarer': bidding.get_decl_i(contract),
                'strain_i': bidding.get_strain_i(contract)
            }
            with shelve.open(f"{base_path}/{db_name}") as db:
                deal = result
                sys.stderr.write('{1} Board Bid in {0:0.2f} seconds.\n'.format(time.time() - t_start, datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
                db[uuid.uuid4().hex] = deal

    if db_name:
        sys.stderr.write(f"Boards saved in {base_path}/{db_name}\n")

